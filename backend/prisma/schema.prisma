generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String     @id @default(cuid())
  email              String     @unique
  name               String?
  password           String?
  role               Role       @default(USER)
  provider           String     @default("credentials")
  providerId         String?
  tokenVersion       Int        @default(0)
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  stripeCustomerId   String?    @unique
  subscriptionStatus String?
  modelPreferences   Json?      @default("{\"sonar\": true, \"gpt-4.1-mini\": true, \"gemini-2.5-flash\": true, \"claude-3-5-haiku-20241022\": true}")
  trialEndsAt        DateTime?
  trialStartedAt     DateTime?
  blogPosts          BlogPost[]
  companies          Company[]
  // Billing relations
  billingSettings    UserBillingSettings?
  billingPeriods     UserBillingPeriod[]
  budgetHolds        BudgetHold[]
  usageEvents        UsageEvent[]
}

model Company {
  id                   String                       @id @default(cuid())
  name                 String
  website              String                       @unique
  industry             String?
  userId               String
  createdAt            DateTime                     @default(now())
  updatedAt            DateTime                     @updatedAt
  questionsReady       Boolean                      @default(false)
  // Per-company model preferences (overrides user-level preferences when set)
  modelPreferences     Json?
  // Optional report schedule configuration for this company
  reportSchedule       ReportSchedule?
  reportScheduleDates  ReportScheduleDate[]
  user                 User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  competitors          Competitor[]
  inclusionRateHistory InclusionRateHistory[]
  mentions             Mention[]
  questions            Question[]
  reportMetrics        ReportMetric[]
  runs                 ReportRun[]
  sentimentOverTime    SentimentOverTime[]
  shareOfVoiceHistory  ShareOfVoiceHistory[]
  optimizationTasks    VisibilityOptimizationTask[]
  webAuditRuns         WebAuditRun[]
  analyticsIntegrations AnalyticsIntegration[]
  googleOAuthTokens    GoogleOAuthToken[]
  ga4Properties        Ga4Property[]
  gscSites             GscSite[]
  ga4DailyMetrics      Ga4DailyMetrics[]
  ga4RealtimeSnapshots Ga4RealtimeSnapshot[]
  gscDailyMetrics      GscDailyMetrics[]
  syncJobs             SyncJob[]
  // Billing usage events for attribution
  usageEvents          UsageEvent[]

  @@index([userId])
}

model Competitor {
  id          String    @id @default(cuid())
  name        String
  companyId   String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  website     String
  isGenerated Boolean   @default(false)
  isAccepted  Boolean?
  company     Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  mentions    Mention[]

  @@unique([companyId, website])
  @@index([companyId])
}

model Question {
  id        String     @id @default(cuid())
  query     String
  type      String?
  intent    String?
  isActive  Boolean    @default(false)
  source    String     @default("user")
  companyId String
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  company   Company    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  responses Response[]

  @@index([companyId])
  @@index([isActive])
  @@index([source])
  @@index([type])
  @@index([intent])
}

model ReportRun {
  id                   String                       @id @default(cuid())
  companyId            String
  status               String
  stepStatus           String?
  tokensUsed           Int?
  usdCost              Float?
  traceId              String?
  createdAt            DateTime                     @default(now())
  updatedAt            DateTime                     @updatedAt
  aiVisibilitySummary  String?
  jobId                String?                      @unique
  // Billing flag: whether this report counts as overage for the billing period
  isOverage            Boolean                      @default(false)
  inclusionRateHistory InclusionRateHistory[]
  sentimentScores      SentimentScore[]
  reportMetrics        ReportMetric[]
  company              Company                      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  responses            Response[]
  sentimentOverTime    SentimentOverTime[]
  shareOfVoiceHistory  ShareOfVoiceHistory[]
  optimizationTasks    VisibilityOptimizationTask[]
  // Billing relations
  budgetHolds          BudgetHold[]
  usageEvents          UsageEvent[]

  @@index([companyId])
}

model SentimentScore {
  id        String    @id @default(cuid())
  runId     String
  version   Int       @default(1)
  name      String
  value     Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  engine    String?
  reportRun ReportRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
  @@map("Metric")
}

model Response {
  id         String     @id @default(cuid())
  questionId String
  content    String
  model      String
  engine     String
  runId      String
  metadata   Json?
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  citations  Citation[]
  mentions   Mention[]
  question   Question   @relation(fields: [questionId], references: [id], onDelete: Cascade)
  run        ReportRun  @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([questionId])
  @@index([runId])
  @@index([engine])
  @@index([model])
}

model Mention {
  id           String      @id @default(cuid())
  responseId   String
  position     Int
  competitorId String?
  companyId    String?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  company      Company?    @relation(fields: [companyId], references: [id], onDelete: Cascade)
  competitor   Competitor? @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  response     Response    @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@index([responseId])
  @@index([competitorId])
  @@index([companyId])
  @@index([responseId, companyId])
  @@index([responseId, competitorId])
}

model Citation {
  id         String   @id @default(cuid())
  responseId String
  url        String
  title      String
  domain     String
  accessedAt DateTime
  position   Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  response   Response @relation(fields: [responseId], references: [id], onDelete: Cascade)

  @@index([responseId])
  @@index([domain])
  @@index([url])
  @@index([responseId, position])
}

model ReportMetric {
  id                     String    @id @default(cuid())
  reportId               String
  companyId              String
  aiModel                String
  shareOfVoice           Float
  shareOfVoiceChange     Float?
  averageInclusionRate   Float
  averageInclusionChange Float?
  averagePosition        Float
  averagePositionChange  Float?
  sentimentChange        Float?
  topRankingsCount       Int?
  rankingsChange         Float?
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt
  competitorRankings     Json?
  topQuestions           Json?
  sentimentDetails       Json?
  sentimentScore         Json?
  company                Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  report                 ReportRun @relation(fields: [reportId], references: [id], onDelete: Cascade)

  @@unique([reportId, aiModel])
  @@index([companyId])
}

model ShareOfVoiceHistory {
  id           String    @id @default(cuid())
  companyId    String
  date         DateTime
  aiModel      String
  shareOfVoice Float
  reportRunId  String
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun    ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)

  @@unique([companyId, reportRunId, aiModel])
  @@index([companyId, aiModel])
  @@index([companyId, date])
}

/// Report schedule configuration for a company
enum ReportScheduleMode {
  MANUAL
  DAILY
  WEEKLY
  CUSTOM
}

model ReportSchedule {
  id         String             @id @default(cuid())
  companyId  String             @unique
  mode       ReportScheduleMode @default(DAILY)
  timezone   String?            // IANA timezone, e.g. "America/Los_Angeles"
  weeklyDays Int[]              // 0 (Sunday) - 6 (Saturday)
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt

  company    Company            @relation(fields: [companyId], references: [id], onDelete: Cascade)
}

// Specific calendar dates when reports should run (interpreted in schedule.timezone)
model ReportScheduleDate {
  id        String   @id @default(cuid())
  companyId String
  date      DateTime // Only the calendar date is significant (time component ignored)
  createdAt DateTime @default(now())

  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, date])
}

model InclusionRateHistory {
  id            String    @id @default(cuid())
  companyId     String
  date          DateTime
  aiModel       String
  inclusionRate Float
  reportRunId   String
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  company       Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun     ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)

  @@unique([companyId, reportRunId, aiModel])
  @@index([companyId, aiModel])
  @@index([companyId, date])
}

model SentimentOverTime {
  id             String    @id @default(cuid())
  companyId      String
  date           DateTime
  aiModel        String
  sentimentScore Float
  reportRunId    String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  company        Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun      ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)

  @@unique([companyId, reportRunId, aiModel])
  @@index([companyId, aiModel])
  @@index([companyId, date])
}

model VisibilityOptimizationTask {
  id           String    @id @default(cuid())
  taskId       String
  reportRunId  String
  companyId    String
  title        String
  description  String
  category     String
  priority     String
  impactMetric String
  dependencies Json
  isCompleted  Boolean   @default(false)
  completedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  status       String    @default("NOT_STARTED")
  company      Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun    ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)

  @@unique([reportRunId, taskId])
  @@index([companyId])
  @@index([reportRunId])
  @@index([status])
}

model BlogPost {
  id                String      @id @default(cuid())
  title             String
  slug              String      @unique
  content           String
  excerpt           String?
  coverImage        String?
  published         Boolean     @default(false)
  publishedAt       DateTime?
  authorId          String
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  metaTitle         String?
  metaDescription   String?
  canonicalUrl      String?
  openGraphImage    String?
  twitterCard       String?     @default("summary_large_image")
  tags              String[]
  estimatedReadTime Int?
  media             BlogMedia[]
  author            User        @relation(fields: [authorId], references: [id])

  @@index([published])
  @@index([publishedAt])
  @@index([authorId])
  @@index([slug])
  @@index([tags])
}

model BlogMedia {
  id         String   @id @default(cuid())
  url        String
  filename   String
  mimeType   String
  size       Int
  alt        String?
  blogPostId String
  createdAt  DateTime @default(now())
  blogPost   BlogPost @relation(fields: [blogPostId], references: [id], onDelete: Cascade)

  @@index([blogPostId])
}

model WebAuditRun {
  id               String    @id @default(cuid())
  companyId        String
  url              String
  status           String    // 'queued', 'running', 'completed', 'failed'
  requestedAt      DateTime  @default(now())
  completedAt      DateTime?

  // Core Scores (0-100)
  performanceScore Int?
  seoScore         Int?
  geoScore         Int?
  accessibilityScore Int?
  securityScore    Int?

  // Technical Results
  performance      Json?     // Core Web Vitals, load times
  seoTechnical     Json?     // robots.txt, meta tags, headers
  geoOptimization  Json?     // Schema markup, AI-readable content
  accessibility    Json?     // WCAG compliance checks
  security         Json?     // HTTPS, headers, vulnerabilities

  // Error handling
  errorMessage     String?

  company          Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([status])
  @@index([requestedAt])
}

model AnalyticsIntegration {
  id                 String    @id @default(cuid())
  companyId          String
  integrationName    String    // "google_search_console" | "manual_tracking"
  status             String    // "pending" | "verified" | "active" | "failed"
  verificationMethod String?   // "meta_tag" | "dns_record" | "file_upload" | "oauth"
  verificationToken  String?
  gscPropertyUrl     String?   // For GSC integration
  accessToken        String?   // Encrypted OAuth token
  refreshToken       String?   // Encrypted OAuth refresh token
  trackingCode       String?   // Generated tracking snippet
  lastSyncAt         DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  company            Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  analyticsData      AnalyticsData[]

  @@index([companyId])
  @@index([status])
  @@index([integrationName])
}

model AnalyticsData {
  id            String    @id @default(cuid())
  integrationId String
  date          DateTime
  source        String    // "search_console" | "manual_tracking"
  query         String?   // Search query (GSC)
  page          String?   // Landing page URL
  impressions   Int?
  clicks        Int?
  ctr           Float?    // Click-through rate
  position      Float?    // Average position
  searchVolume  Int?      // Estimated search volume
  attribution   Json?     // Attribution data
  deviceType    String?   // "desktop" | "mobile" | "tablet"
  country       String?   // Country code
  createdAt     DateTime  @default(now())
  integration   AnalyticsIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)

  @@index([integrationId])
  @@index([date])
  @@index([source])
  @@index([query])
  @@index([page])
  @@index([integrationId, date])
}

enum Role {
  USER
  ADMIN
}

/// New models for Google integrations and normalized analytics caches
model GoogleOAuthToken {
  id          String   @id @default(cuid())
  companyId   String
  provider    String   // 'google'
  scopes      String[]
  accessToken String   // Encrypted at rest
  refreshToken String? // Encrypted at rest
  expiry      DateTime?
  tokenHash   String?  // SHA-256 hash of refresh token to detect rotation
  revokedAt   DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([companyId, provider])
}

model Ga4Property {
  id          String   @id @default(cuid())
  companyId   String
  propertyId  String   // GA4 property numeric id as string
  displayName String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, propertyId])
  @@index([companyId])
}

model GscSite {
  id                String   @id @default(cuid())
  companyId         String
  siteUrl           String
  verificationState String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  company           Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, siteUrl])
  @@index([companyId])
}

model Ga4DailyMetrics {
  id                      String   @id @default(cuid())
  companyId               String
  propertyId              String
  date                    DateTime
  country                 String?
  device                  String?
  pagePath                String?
  channelGroup            String?
  sessions                Int?
  totalUsers              Int?
  activeUsers             Int?
  engagedSessions         Int?
  eventCount              Int?
  conversions             Int?
  sessionDurationSeconds  Float?
  avgEngagementTime       Float?
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  company                 Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([companyId, propertyId, date])
  @@index([propertyId, date])
  @@unique([companyId, propertyId, date, country, device, pagePath, channelGroup])
}

model Ga4RealtimeSnapshot {
  id             String   @id @default(cuid())
  companyId      String
  propertyId     String
  capturedAt     DateTime @default(now())
  concurrentUsers Int?
  topPages       Json?

  company        Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([propertyId, capturedAt])
  @@unique([companyId, propertyId, capturedAt])
}

model GscDailyMetrics {
  id         String   @id @default(cuid())
  companyId  String
  siteUrl    String
  date       DateTime
  query      String?
  page       String?
  country    String?
  device     String?
  impressions Int?
  clicks     Int?
  ctr        Float?
  position   Float?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  company    Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId])
  @@index([siteUrl, date])
  @@unique([companyId, siteUrl, date, query, page, country, device])
}

model SyncJob {
  id           String   @id @default(cuid())
  companyId    String
  provider     String   // 'ga4' | 'gsc'
  targetType   String   // 'property' | 'site'
  targetId     String
  startDate    DateTime
  endDate      DateTime
  status       String   // 'queued' | 'running' | 'success' | 'failed' | 'backoff'
  priority     Int      @default(0)
  attempt      Int      @default(0)
  backoffUntil DateTime?
  lastError    String?
  scheduledAt  DateTime @default(now())
  startedAt    DateTime?
  finishedAt   DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  logs         SyncLog[]

  @@index([companyId])
  @@index([status])
  @@index([provider, targetType, targetId])
}

model SyncLog {
  id        String   @id @default(cuid())
  syncJobId String
  level     String   // 'info' | 'warn' | 'error'
  code      String?
  message   String
  meta      Json?
  createdAt DateTime @default(now())

  job       SyncJob  @relation(fields: [syncJobId], references: [id], onDelete: Cascade)

  @@index([syncJobId])
  @@index([level])
}

/// Billing period lifecycle state
enum BillingPeriodState {
  OPEN
  INVOICED
  CLOSED
}

/// Budget hold status for overage reports
enum BudgetHoldStatus {
  HELD
  APPLIED
  RELEASED
}

/// Usage event type captured during report execution
enum UsageEventType {
  RESPONSE
  SENTIMENT
}

/// Per-user billing settings and runtime subscription metadata
model UserBillingSettings {
  id                    String   @id @default(cuid())
  userId                String   @unique
  planTier              String
  billingInterval       String   // MONTHLY | ANNUAL (string for forward-compat)
  stripeCustomerId      String   @unique
  stripeSubscriptionId  String?
  currentPeriodStart    DateTime?
  currentPeriodEnd      DateTime?
  budgetEnabled         Boolean  @default(false)
  overageBudgetCents    Int?     // minimum 5000 when enabled
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// One row per billing period per user, aggregates and Stripe invoice linkage
model UserBillingPeriod {
  id                      String              @id @default(cuid())
  userId                  String
  periodStart             DateTime
  periodEnd               DateTime
  includedReportsLimit    Int
  reportsUsed             Int                 @default(0)
  overageResponseCount    Int                 @default(0)
  overageSentimentCount   Int                 @default(0)
  overageAmountCents      Int                 @default(0)
  subscriptionInvoiceId   String?
  stripeOverageInvoiceId  String?
  state                   BillingPeriodState  @default(OPEN)
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt

  user                    User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  budgetHolds             BudgetHold[]
  usageEvents             UsageEvent[]

  @@index([userId])
  @@index([periodStart, periodEnd])
}

/// Pre-flight reserved budget for an overage report; applied or released at finalize
model BudgetHold {
  id               String             @id @default(cuid())
  userId           String
  billingPeriodId  String
  reportRunId      String
  amountCents      Int
  status           BudgetHoldStatus   @default(HELD)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  billingPeriod    UserBillingPeriod  @relation(fields: [billingPeriodId], references: [id], onDelete: Cascade)
  reportRun        ReportRun          @relation(fields: [reportRunId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([billingPeriodId])
  @@index([reportRunId])
}

/// Fine-grained usage for billing and analytics
model UsageEvent {
  id               String            @id @default(cuid())
  userId           String
  companyId        String
  reportRunId      String
  billingPeriodId  String
  type             UsageEventType
  quantity         Int               @default(1)
  unitPriceCents   Int
  isOverage        Boolean           @default(false)
  occurredAt       DateTime          @default(now())
  metadata         Json?

  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  company          Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun        ReportRun         @relation(fields: [reportRunId], references: [id], onDelete: Cascade)
  billingPeriod    UserBillingPeriod @relation(fields: [billingPeriodId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([companyId])
  @@index([reportRunId])
  @@index([billingPeriodId])
  @@index([type])
  @@index([occurredAt])
}
