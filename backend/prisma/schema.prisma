generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  name               String?
  password           String?
  role               Role      @default(USER)
  provider           String    @default("credentials")
  providerId         String?
  tokenVersion       Int       @default(0)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  stripeCustomerId   String?   @unique
  subscriptionStatus String?
  companies          Company[]
  blogPosts          BlogPost[]
}

model Company {
  id                    String                       @id @default(cuid())
  name                  String
  website               String                       @unique
  industry              String?
  userId                String
  createdAt             DateTime                     @default(now())
  updatedAt             DateTime                     @updatedAt
  benchmarkingQuestions BenchmarkingQuestion[]       // Only user-created questions
  user                  User                         @relation(fields: [userId], references: [id], onDelete: Cascade)
  competitors           Competitor[]
  runs                  ReportRun[]
  reportMetrics         ReportMetric[]
  shareOfVoiceHistory   ShareOfVoiceHistory[]
  sentimentOverTime     SentimentOverTime[]
  optimizationTasks     VisibilityOptimizationTask[]
  fanoutQuestions       FanoutQuestion[]             // New fanout questions
  fanoutMentions        FanoutMention[]              // New fanout mentions

  @@index([userId])
}

model Competitor {
  id            String          @id @default(cuid())
  name          String
  companyId     String
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  website       String
  isGenerated   Boolean         @default(false)
  company       Company         @relation(fields: [companyId], references: [id], onDelete: Cascade)
  fanoutMentions FanoutMention[] // New fanout mentions

  @@index([companyId])
  @@unique([companyId, website])
}

// Simplified benchmarking questions - only user-created questions
model BenchmarkingQuestion {
  id             String            @id @default(cuid())
  text           String
  companyId      String
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  company        Company           @relation(fields: [companyId], references: [id], onDelete: Cascade)
  fanoutQuestions FanoutQuestion[] // Fanout questions generated from this base question

  @@index([companyId])
}

// New fanout questions table
model FanoutQuestion {
  id                    String         @id @default(cuid())
  baseQuestionId        String         // References BenchmarkingQuestion
  text                  String         // The generated fanout query text
  type                  String         // paraphrase, comparison, temporal, etc.
  sourceModel           String         // Which model generated this query
  companyId             String
  createdAt             DateTime       @default(now())
  updatedAt             DateTime       @updatedAt
  baseQuestion          BenchmarkingQuestion @relation(fields: [baseQuestionId], references: [id], onDelete: Cascade)
  company               Company        @relation(fields: [companyId], references: [id], onDelete: Cascade)
  responses             FanoutResponse[]

  @@unique([baseQuestionId, type, sourceModel, text])
  @@index([baseQuestionId])
  @@index([companyId])
  @@index([type])
  @@index([sourceModel])
}

model ReportRun {
  id                  String                       @id @default(cuid())
  companyId           String
  status              String
  stepStatus          String?
  tokensUsed          Int?
  usdCost             Float?
  traceId             String?
  aiVisibilitySummary String?                      
  fanoutData          Json?                        // Store complete fanout generation data
  createdAt           DateTime                     @default(now())
  updatedAt           DateTime                     @updatedAt
  sentimentScores     SentimentScore[]
  company             Company                      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportMetrics       ReportMetric[]
  shareOfVoiceHistory ShareOfVoiceHistory[]
  sentimentOverTime   SentimentOverTime[]
  optimizationTasks   VisibilityOptimizationTask[]
  fanoutResponses     FanoutResponse[]             // New fanout responses

  @@index([companyId])
}

model SentimentScore {
  id        String    @id @default(cuid())
  runId     String
  version   Int       @default(1)
  name      String
  value     Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  engine    String?
  reportRun ReportRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
  @@map("Metric")
}

// New fanout responses table
model FanoutResponse {
  id              String         @id @default(cuid())
  fanoutQuestionId String
  engine          String         // openai, anthropic, google, perplexity
  model           String         // specific model name
  content         String         // the response content
  runId           String
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  mentions        FanoutMention[]
  fanoutQuestion  FanoutQuestion @relation(fields: [fanoutQuestionId], references: [id], onDelete: Cascade)
  run             ReportRun      @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([fanoutQuestionId])
  @@index([runId])
  @@index([engine])
  @@index([model])
}

// New fanout mentions table
model FanoutMention {
  id               String         @id @default(cuid())
  fanoutResponseId String
  position         Int
  competitorId     String?
  companyId        String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  company          Company?       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  competitor       Competitor?    @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  fanoutResponse   FanoutResponse @relation(fields: [fanoutResponseId], references: [id], onDelete: Cascade)

  @@index([fanoutResponseId])
  @@index([competitorId])
  @@index([companyId])
  @@index([fanoutResponseId, companyId])
  @@index([fanoutResponseId, competitorId])
}

model ReportMetric {
  id                     String    @id @default(cuid())
  reportId               String
  companyId              String
  aiModel                String
  shareOfVoice           Float
  shareOfVoiceChange     Float?
  averageInclusionRate   Float
  averageInclusionChange Float?
  averagePosition        Float
  averagePositionChange  Float?
  sentimentScore         Float?
  sentimentChange        Float?
  topRankingsCount       Int?
  rankingsChange         Float?
  competitorRankings     Json?
  topQuestions           Json?      // Now includes fanout question data
  sentimentDetails       Json?
  report                 ReportRun @relation(fields: [reportId], references: [id], onDelete: Cascade)
  company                Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  @@unique([reportId, aiModel])
  @@index([companyId])
}

model ShareOfVoiceHistory {
  id           String   @id @default(cuid())
  companyId    String
  date         DateTime @db.Date
  aiModel      String
  shareOfVoice Float
  reportRunId  String
  company      Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun    ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([companyId, date, aiModel])
  @@index([companyId, aiModel])
}

model SentimentOverTime {
  id             String   @id @default(cuid())
  companyId      String
  date           DateTime @db.Date
  aiModel        String
  sentimentScore Float
  reportRunId    String
  company        Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  reportRun      ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([companyId, date, aiModel])
  @@index([companyId, aiModel])
}

model VisibilityOptimizationTask {
  id             String   @id @default(cuid())
  taskId         String   // T01, T02, etc.
  reportRunId    String
  companyId      String
  title          String
  description    String
  category       String   // Technical SEO, Content Creation, etc.
  priority       String   // High, Medium, Low
  impactMetric   String   // shareOfVoice, inclusionRate, etc.
  dependencies   Json     // Array of task IDs
  status         String   @default("NOT_STARTED") // NOT_STARTED, IN_PROGRESS, COMPLETED
  isCompleted    Boolean  @default(false)
  completedAt    DateTime?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  reportRun      ReportRun @relation(fields: [reportRunId], references: [id], onDelete: Cascade)
  company        Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([reportRunId, taskId])
  @@index([companyId])
  @@index([reportRunId])
  @@index([status])
}

model BlogPost {
  id          String      @id @default(cuid())
  title       String
  slug        String      @unique
  content     String      // Rich HTML content from editor
  excerpt     String?     // Auto-generated or manual excerpt
  coverImage  String?     // URL to cover image
  published   Boolean     @default(false)
  publishedAt DateTime?
  authorId    String
  author      User        @relation(fields: [authorId], references: [id])
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  media       BlogMedia[]

  @@index([published])
  @@index([publishedAt])
  @@index([authorId])
}

model BlogMedia {
  id         String   @id @default(cuid())
  url        String   // Full URL to the media file
  filename   String   // Original filename
  mimeType   String   // image/jpeg, image/png, etc.
  size       Int      // File size in bytes
  alt        String?  // Alt text for accessibility
  blogPostId String
  blogPost   BlogPost @relation(fields: [blogPostId], references: [id], onDelete: Cascade)
  createdAt  DateTime @default(now())

  @@index([blogPostId])
}

enum Role {
  USER
  ADMIN
}
