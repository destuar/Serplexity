generator client {
  provider      = "prisma-client-js"
  output        = "../node_modules/.prisma/client"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String    @id @default(cuid())
  email              String    @unique
  name               String?
  password           String?
  role               Role      @default(USER)
  provider           String    @default("credentials")
  providerId         String?
  tokenVersion       Int       @default(0)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt
  stripeCustomerId   String?   @unique
  subscriptionStatus String?
  companies          Company[]
}

model Company {
  id                    String                 @id @default(cuid())
  name                  String
  website               String
  industry              String?
  userId                String
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  benchmarkingQuestions BenchmarkingQuestion[]
  user                  User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  competitors           Competitor[]
  products              Product[]
  runs                  ReportRun[]
  mentions              VisibilityMention[]
  benchmarkMentions     BenchmarkMention[]

  @@index([userId])
}

model Competitor {
  id                   String               @id @default(cuid())
  name                 String
  companyId            String
  createdAt            DateTime             @default(now())
  updatedAt            DateTime             @updatedAt
  website              String
  isGenerated          Boolean              @default(false)
  company              Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  mentions             VisibilityMention[]
  benchmarkMentions    BenchmarkMention[]

  @@index([companyId])
}

model BenchmarkingQuestion {
  id                 String                 @id @default(cuid())
  text               String
  companyId          String
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  isGenerated        Boolean                @default(false)
  originalQuestionId String?
  company            Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  originalQuestion   BenchmarkingQuestion?  @relation("Variations", fields: [originalQuestionId], references: [id], onDelete: NoAction)
  variations         BenchmarkingQuestion[] @relation("Variations")
  benchmarkResponses BenchmarkResponse[]

  @@index([companyId])
  @@index([originalQuestionId])
}

model Product {
  id                  String               @id @default(cuid())
  name                String
  companyId           String
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  company             Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  visibilityQuestions VisibilityQuestion[]

  @@index([companyId])
}

model VisibilityQuestion {
  id        String   @id @default(cuid())
  question  String   @db.Text
  productId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  responses VisibilityResponse[]

  @@index([productId])
}

model ReportRun {
  id                    String                 @id @default(cuid())
  companyId             String
  status                String
  stepStatus            String?
  tokensUsed            Int?
  usdCost               Float?
  traceId               String?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  metrics               Metric[]
  company               Company                @relation(fields: [companyId], references: [id], onDelete: Cascade)
  visibilityResponses   VisibilityResponse[]
  benchmarkResponses    BenchmarkResponse[]
  dashboardData         DashboardData?

  @@index([companyId])
}

model DashboardData {
  id                    String    @id @default(cuid())
  runId                 String    @unique
  companyId             String
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  
  // Storing complex, nested data as JSON is efficient for this use case.
  brandShareOfVoice     Json
  shareOfVoiceHistory   Json
  averagePosition       Json
  averageInclusionRate  Json
  competitorRankings    Json
  topQuestions          Json
  sentimentOverTime     Json

  run                   ReportRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
  @@index([companyId])
}

model Metric {
  id        String    @id @default(cuid())
  runId     String
  version   Int       @default(1)
  name      String
  value     Json
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  engine    String?
  reportRun ReportRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model VisibilityResponse {
  id                   String    @id @default(cuid())
  visibilityQuestionId String
  engine               String
  model                String
  content              String    @db.Text
  runId                String
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  mentions             VisibilityMention[]
  question             VisibilityQuestion @relation(fields: [visibilityQuestionId], references: [id], onDelete: Cascade)
  run                  ReportRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([visibilityQuestionId])
  @@index([runId])
}

model BenchmarkResponse {
  id                    String             @id @default(cuid())
  benchmarkQuestionId   String
  engine                String
  model                 String
  content               String             @db.Text
  runId                 String
  createdAt             DateTime           @default(now())
  updatedAt             DateTime           @updatedAt
  benchmarkQuestion     BenchmarkingQuestion @relation(fields: [benchmarkQuestionId], references: [id], onDelete: Cascade)
  run                   ReportRun          @relation(fields: [runId], references: [id], onDelete: Cascade)
  benchmarkMentions     BenchmarkMention[]

  @@index([benchmarkQuestionId])
  @@index([runId])
}

model VisibilityMention {
  id                   String             @id @default(cuid())
  visibilityResponseId String
  position             Int
  competitorId         String?
  companyId            String?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  visibilityResponse   VisibilityResponse @relation(fields: [visibilityResponseId], references: [id], onDelete: Cascade)
  competitor           Competitor?        @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  company              Company?           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([visibilityResponseId])
  @@index([competitorId])
  @@index([companyId])
}

model BenchmarkMention {
  id                  String             @id @default(cuid())
  benchmarkResponseId String
  position            Int
  competitorId        String?
  companyId           String?
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt
  benchmarkResponse   BenchmarkResponse  @relation(fields: [benchmarkResponseId], references: [id], onDelete: Cascade)
  competitor          Competitor?        @relation(fields: [competitorId], references: [id], onDelete: Cascade)
  company             Company?           @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([benchmarkResponseId])
  @@index([competitorId])
  @@index([companyId])
}

enum Role {
  USER
  ADMIN
}
