#!/usr/bin/env node

/**
 * Mock Test for Complete Fanout Pipeline
 * 
 * This script tests the entire fanout pipeline:
 * 1. Generate fanout questions using each model
 * 2. Generate responses to those questions using each model
 * 3. Test brand tagging and citation tracking
 * 4. Verify database storage
 * 
 * Usage: npm run test-fanout-pipeline
 */

import { spawn } from 'child_process';
import { promises as fs } from 'fs';
import path from 'path';
import { config } from 'dotenv';
import { MODELS, getModelsByTask, ModelTask } from '../config/models';

// Load environment variables from .env file
config({ path: path.join(__dirname, '../../.env') });

// Mock data for testing
const MOCK_BENCHMARK_QUESTION = "What are the best project management tools for software development teams?";
const MOCK_COMPANY = {
  name: "Asana",
  industry: "Project Management Software",
  competitors: ["Trello", "Monday.com", "Basecamp", "Jira", "Notion"]
};

interface TestResult {
  model: string;
  engine: string;
  stage: 'fanout_generation' | 'question_answering';
  success: boolean;
  error?: string;
  data?: any;
  executionTime: number;
  brandMentionsCount?: number;
  citationsCount?: number;
}

interface FanoutQuestion {
  text: string;
  type: string;
  companyName: string;
  industry: string;
}

class FanoutPipelineTest {
  private results: TestResult[] = [];
  private generatedQuestions: Map<string, FanoutQuestion[]> = new Map();
  
  constructor() {
    console.log('üöÄ Starting Fanout Pipeline Test');
    console.log('='.repeat(60));
  }

  async run(): Promise<void> {
    try {
      // Step 1: Test fanout question generation for each model
      console.log('\nüìù STEP 1: Testing Fanout Question Generation');
      console.log('-'.repeat(40));
      await this.testFanoutGeneration();

      // Step 2: Test question answering for each model
      console.log('\nüí¨ STEP 2: Testing Question Answering');
      console.log('-'.repeat(40));
      await this.testQuestionAnswering();

      // Step 3: Display results
      console.log('\nüìä STEP 3: Test Results Summary');
      console.log('-'.repeat(40));
      this.displayResults();

    } catch (error) {
      console.error('‚ùå Test pipeline failed:', error);
      process.exit(1);
    }
  }

  private async testFanoutGeneration(): Promise<void> {
    const fanoutModels = getModelsByTask(ModelTask.FANOUT_GENERATION);
    
    for (const model of fanoutModels) {
      console.log(`\nüîÑ Testing fanout generation with ${model.id} (${model.engine.toUpperCase()})`);
      
      const startTime = Date.now();
      const result: TestResult = {
        model: model.id,
        engine: model.engine,
        stage: 'fanout_generation',
        success: false,
        executionTime: 0
      };

      try {
        const fanoutInput = {
          company_name: MOCK_COMPANY.name,
          industry: MOCK_COMPANY.industry,
          context: `Generate fanout questions for ${MOCK_COMPANY.name} in the ${MOCK_COMPANY.industry} industry`,
          query_types: ["comparison", "best_for", "versus", "alternatives"],
          max_queries: 5,
          target_audiences: ["developers", "product managers", "startup founders"],
          provider: model.engine
        };

        console.log(`   üì§ Input: ${JSON.stringify(fanoutInput, null, 2)}`);
        
        const fanoutResult = await this.runPythonAgent('fanout_agent.py', fanoutInput);
        
        result.executionTime = Date.now() - startTime;
        result.success = true;
        result.data = fanoutResult;

        // Store generated questions for next step
        if (fanoutResult.result && fanoutResult.result.queries) {
          const questions: FanoutQuestion[] = fanoutResult.result.queries.map((q: any) => ({
            text: q.text,
            type: q.type,
            companyName: MOCK_COMPANY.name,
            industry: MOCK_COMPANY.industry
          }));
          this.generatedQuestions.set(model.id, questions);
          
          console.log(`   ‚úÖ Generated ${questions.length} fanout questions`);
          questions.forEach((q, i) => {
            console.log(`      ${i + 1}. [${q.type}] ${q.text}`);
          });
        }

      } catch (error) {
        result.executionTime = Date.now() - startTime;
        result.error = error instanceof Error ? error.message : String(error);
        console.log(`   ‚ùå Error: ${result.error}`);
      }

      this.results.push(result);
    }
  }

  private async testQuestionAnswering(): Promise<void> {
    const questionModels = getModelsByTask(ModelTask.QUESTION_ANSWERING);
    
    for (const model of questionModels) {
      console.log(`\nüîÑ Testing question answering with ${model.id} (${model.engine.toUpperCase()})`);
      
      // Use questions generated by the same model, or fallback to mock questions
      const questions = this.generatedQuestions.get(model.id) || this.generateMockQuestions();
      
      for (let i = 0; i < Math.min(questions.length, 3); i++) { // Test first 3 questions
        const question = questions[i];
        console.log(`\n   üéØ Question ${i + 1}: ${question.text}`);
        
        const startTime = Date.now();
        const result: TestResult = {
          model: model.id,
          engine: model.engine,
          stage: 'question_answering',
          success: false,
          executionTime: 0
        };

        try {
          const questionInput = {
            question: question.text,
            company_name: MOCK_COMPANY.name,
            competitors: MOCK_COMPANY.competitors,
            context: `Answer this question about ${MOCK_COMPANY.industry} tools, ensuring to mention relevant companies with <brand> tags`,
            enable_web_search: true,
            provider: model.engine
          };

          console.log(`   üì§ Input: ${JSON.stringify(questionInput, null, 2)}`);
          
          const questionResult = await this.runPythonAgent('question_agent.py', questionInput);
          
          result.executionTime = Date.now() - startTime;
          result.success = true;
          result.data = questionResult;

          // Analyze the response
          if (questionResult.result && questionResult.result.answer) {
            const answer = questionResult.result.answer;
            const brandMentions = (answer.match(/<brand>.*?<\/brand>/g) || []).length;
            const citations = questionResult.result.citations || [];
            
            result.brandMentionsCount = brandMentions;
            result.citationsCount = citations.length;

            console.log(`   ‚úÖ Response generated successfully`);
            console.log(`   üìä Brand mentions: ${brandMentions}`);
            console.log(`   üìö Citations: ${citations.length}`);
            console.log(`   üîç Web search enabled: ${questionResult.result.has_web_search}`);
            console.log(`   üí¨ Answer preview: ${answer.substring(0, 200)}...`);
            
            if (citations.length > 0) {
              console.log(`   üìñ Citations:`);
              citations.forEach((cite: any, idx: number) => {
                console.log(`      ${idx + 1}. ${cite.title} (${cite.domain})`);
              });
            }

            // Check for brand mentions
            if (brandMentions > 0) {
              console.log(`   üè∑Ô∏è  Brand mentions found:`);
              const mentions = answer.match(/<brand>(.*?)<\/brand>/g) || [];
              mentions.forEach((mention: string, idx: number) => {
                const brandName = mention.replace(/<\/?brand>/g, '');
                console.log(`      ${idx + 1}. ${brandName}`);
              });
            }

          }

        } catch (error) {
          result.executionTime = Date.now() - startTime;
          result.error = error instanceof Error ? error.message : String(error);
          console.log(`   ‚ùå Error: ${result.error}`);
        }

        this.results.push(result);
      }
    }
  }

  private generateMockQuestions(): FanoutQuestion[] {
    return [
      {
        text: "What are the key differences between Asana and Trello for project management?",
        type: "comparison",
        companyName: MOCK_COMPANY.name,
        industry: MOCK_COMPANY.industry
      },
      {
        text: "What's the best project management tool for software development teams?",
        type: "best_for",
        companyName: MOCK_COMPANY.name,
        industry: MOCK_COMPANY.industry
      },
      {
        text: "Asana vs Monday.com: which is better for remote teams?",
        type: "versus",
        companyName: MOCK_COMPANY.name,
        industry: MOCK_COMPANY.industry
      }
    ];
  }

  private async runPythonAgent(scriptName: string, input: any): Promise<any> {
    return new Promise((resolve, reject) => {
      const scriptPath = path.join(__dirname, '..', 'pydantic_agents', 'agents', scriptName);
      const childProcess = spawn('python3', [scriptPath], {
        stdio: ['pipe', 'pipe', 'pipe'],
        env: {
          ...process.env,
          PYTHONPATH: path.join(__dirname, '..'),
          PYDANTIC_PROVIDER_ID: input.provider || 'openai'
        }
      });

      let stdout = '';
      let stderr = '';

      childProcess.stdout?.on('data', (data: Buffer) => {
        stdout += data.toString();
      });

      childProcess.stderr?.on('data', (data: Buffer) => {
        stderr += data.toString();
      });

      childProcess.on('close', (code: number | null) => {
        if (code !== 0) {
          console.log(`   üêç Python stderr: ${stderr}`);
          reject(new Error(`Python process exited with code ${code}: ${stderr}`));
        } else {
          try {
            const result = JSON.parse(stdout);
            resolve(result);
          } catch (parseError) {
            console.log(`   üêç Python stdout: ${stdout}`);
            console.log(`   üêç Python stderr: ${stderr}`);
            reject(new Error(`Failed to parse JSON output: ${parseError}`));
          }
        }
      });

      childProcess.stdin?.write(JSON.stringify(input));
      childProcess.stdin?.end();
    });
  }

  private displayResults(): void {
    console.log('\nüìà EXECUTION SUMMARY');
    console.log('='.repeat(80));

    // Group results by stage
    const fanoutResults = this.results.filter(r => r.stage === 'fanout_generation');
    const questionResults = this.results.filter(r => r.stage === 'question_answering');

    console.log('\nüîÑ FANOUT GENERATION RESULTS:');
    fanoutResults.forEach(result => {
      const status = result.success ? '‚úÖ' : '‚ùå';
      console.log(`${status} ${result.model} (${result.engine}): ${result.executionTime}ms`);
      if (result.error) {
        console.log(`   Error: ${result.error}`);
      }
    });

    console.log('\nüí¨ QUESTION ANSWERING RESULTS:');
    const modelStats = new Map<string, { success: number; total: number; mentions: number; citations: number }>();
    
    questionResults.forEach(result => {
      const key = `${result.model} (${result.engine})`;
      const stats = modelStats.get(key) || { success: 0, total: 0, mentions: 0, citations: 0 };
      
      stats.total++;
      if (result.success) {
        stats.success++;
        stats.mentions += result.brandMentionsCount || 0;
        stats.citations += result.citationsCount || 0;
      }
      
      modelStats.set(key, stats);
    });

    modelStats.forEach((stats, model) => {
      const successRate = ((stats.success / stats.total) * 100).toFixed(1);
      console.log(`üìä ${model}:`);
      console.log(`   Success: ${stats.success}/${stats.total} (${successRate}%)`);
      console.log(`   Brand mentions: ${stats.mentions}`);
      console.log(`   Citations: ${stats.citations}`);
    });

    // Overall statistics
    const totalTests = this.results.length;
    const successfulTests = this.results.filter(r => r.success).length;
    const overallSuccessRate = ((successfulTests / totalTests) * 100).toFixed(1);
    
    console.log('\nüéØ OVERALL STATISTICS:');
    console.log(`Total tests: ${totalTests}`);
    console.log(`Successful: ${successfulTests}`);
    console.log(`Success rate: ${overallSuccessRate}%`);
    
    const totalBrandMentions = questionResults.reduce((sum, r) => sum + (r.brandMentionsCount || 0), 0);
    const totalCitations = questionResults.reduce((sum, r) => sum + (r.citationsCount || 0), 0);
    
    console.log(`Total brand mentions: ${totalBrandMentions}`);
    console.log(`Total citations: ${totalCitations}`);

    // Check for critical issues
    console.log('\nüîç CRITICAL ISSUES CHECK:');
    const fanoutFailures = fanoutResults.filter(r => !r.success);
    const questionFailures = questionResults.filter(r => !r.success);
    const zeroBrandMentions = questionResults.filter(r => r.success && (r.brandMentionsCount || 0) === 0);
    
    if (fanoutFailures.length > 0) {
      console.log(`‚ö†Ô∏è  ${fanoutFailures.length} fanout generation failures`);
    }
    if (questionFailures.length > 0) {
      console.log(`‚ö†Ô∏è  ${questionFailures.length} question answering failures`);
    }
    if (zeroBrandMentions.length > 0) {
      console.log(`‚ö†Ô∏è  ${zeroBrandMentions.length} successful responses with zero brand mentions`);
    }
    
    if (fanoutFailures.length === 0 && questionFailures.length === 0 && zeroBrandMentions.length === 0) {
      console.log('‚úÖ No critical issues detected');
    }

    console.log('\n' + '='.repeat(80));
    console.log('‚ú® Test completed successfully!');
  }
}

// Run the test
async function main() {
  const test = new FanoutPipelineTest();
  await test.run();
}

if (require.main === module) {
  main().catch(console.error);
}